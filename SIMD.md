## **cpuid** - проверка доступности SIMD

Для проверки используется инструкция **cpuid**, она принимает один параметр который передается через регистр **eax**

В зависимости от переданного параметра можно получить нужную информацию о процессоре

Чтобы узнать поддержку расширений для SIMD, в EAX передается значение 1. В этом случае результат инструкции помещается в регистр ECX. Определенные биты результат могут указывать на поддержку определенных возможностей:
 
    0  | Доступно SSE3
    1  | Доступно PCLMULQDQ
    9  | Доступно SSSE3
    19 | Доступно SSE4.1
    20 | Доступно SSE4.2
    28 | Доступно AVX (Advanced Vector Extensions)

Для дополнительной информации можно установить **eax = 7** и **ecx = 0**, тогда результат будет помещен в **ebx**




#

---
## Регистры

Для работы с дробными числами тут есть целые новые инструкции и регистры, которые могут не работать на старых процессорах, так что надо по аккуратнее

**SIMD** (Single-Instruction, Multiple-Data - "Одна инструкция, много данных") представляет специальный набор инструкций, которые предоставляют параллельную обработку данных. То есть некоторые группы данных могут обрабатываться одновременно, благодаря чему увеличивается производительность и ускоряется выполнение программы. В архитектуре x86-64 инструкции SIMD представлены специальными расширениями SSE/AVX, которые имеют три поколения:

- Архитектура **SSE/SSE2** (Streaming SIMD Extensions), которая предоставляет шестнадцать 128-битных регистров XMM (поддерживают как целочисленные типы данных, так и типы с плавающей точкой)
- Архитектура **AVX/AVX2**, которая поддерживает шестнадцать 256-битных регистров YMM (также поддерживают как целочисленные типы данных, так и типы с плавающей точкой)
- Архитектура **AVX-512**, которая поддерживает до 32-х 512-битных регистров ZMM.

***x64:***

    XMM0 - XMM15
    YMM0 - YMM15
    ZMM0 - ZMM31

***x32:***

    XMM0 - XMM7
    YMM0 - YMM7
    ZMM0 - ZMM7

Регистры XMM (XMM0-XMM15) могут хранить одно 32-разрядное значение с плавающей точкой (то есть значение типа dword) или четыре значения с плавающей точкой одинарной точности (то есть вектор из 4-х значений). Регистры YMM (YMM0-YMM15) могут хранить 8 чисел с плавающей точкой одинарной точности (32-разрядных):

    255 224 192 160 128 96  64  32  0
    |   |   |   |   |   |   |   |   |
    |               |           \   /
    |               |         x1 .float
    |               |               |
    |               \    рег. XMM   /
    |                   x4 .float
    |                               |
    \            рег. YMM           /
                X8 .float

Регистры XMM могут также хранить одно число с плавающей точкой двойной точности - .double или вектор из двух значений чисел .double. Регистры YMM могут хранить вектор из четырех чисел с плавающей точкой двойной точности:

    255     192     128     64      0
    |       |       |       |       |
    |               |       \       /
    |               |       x1 .double
    |               |               |
    |               \    рег. XMM   /
    |                   x2 .double
    |                               |
    \            рег. YMM           /
                X4 .double

Аналогичным образом, регистр XMM может хранить вектор с 16 значениями .byte (YMM - вектор с 32 байтами), с 8 значениями word (YMM - вектор с 16 word), 4 числами .long (YMM - вектор с 8 .long) и 2 числами qword (YMM - 4 qword):

                                    .byte
    |[][][][][][][][][][][][][][][][]|[][][][][][][][][][][][][][][][]|
    |                                |                                |
    |                                \          XMM - 16 byte         /
    \                            YMM - 32 byte                        /
####
                                    .short
    |[  ][  ][  ][  ][  ][  ][  ][  ]|[  ][  ][  ][  ][  ][  ][  ][  ]|
    |                                |                                |
    |                                \          XMM - 8 .short        /
    \                            YMM - 16 .short                      /
####
                                     .long
    |[      ][      ][      ][      ]|[      ][      ][      ][      ]|
    |                                |                                |
    |                                \          XMM - 4 long          /
    \                            YMM - 8 long                         /
####
                                     .quad
    |[              ][              ]|[              ][              ]|
    |                                |                                |
    |                                \          XMM - 2 quad          /
    \                            YMM - 4 quad                         /


### MXCSR - регистр управления / состояния

Тут также есть 32-х битный аналог флагов **MXCSR**

- **0 (IE):** Флаг исключения недопустимой операции. Устанавливается, если была попытка выполнить недопустимую операцию
- **1 (DE):** Флаг исключения денормализации. Устанавливается, если результат операции - денормализованное значение
- **2 (ZE):** Флаг нулевого исключения. Устанавливается, если была предпринята попытка деления на 0.
- **3 (OE):** Флаг переполнения. Устанавливается, если было переполнение.
- **4 (UE):** Флаг потери значимости (underflow). Устанавливается, если была потеря значимости
- **5 (PE):** Флаг потери точности. Устанавливается, если была потеря точности.
- **6 (DAZ):** Денормализованные значения равны 0. Если установлено, денормализованные значения обрабатываются как 0.
- **7 (IM):** Неверная маска операции. Если установлено, исключения недопустимой операции игнорируются
- **8 (DM):** Денормализованная маска. Если установлено, исключения денормализации игнорируются
- **9 (ZM):** Маска деления на ноль. Если установлено, исключения деления на ноль игнорируются
- **10 (OM):** Маска переполнения. Если установлено, исключения переполнения игнорируются
- **11 (UM):** Маска потери значимости. Если установлено, исключения потери значимости игнорируются
- **12 (PM):** Маска точности. Если установлено, исключения точности игнорируются
- **13-14:** Управление округлением. может принимать ряд значений:
  - **00:** округление до ближайшего
  - **01:** округление до -бесконечности
  - **10:** округление до +бесконечности
  - **11:** округление до 0 (усечение)
- **15 (FTZ):** Сброс до нуля. Когда установлено, все условия потери значимости устанавливают регистр в 0

Остальне биты 16-32 зарезервированы и в настоящее время не имеют значения.

Доступ к регистру SSE MXCSR осуществляется с помощью следующих двух инструкций:

```asm
ldmxcsr mem32
stmxcsr mem32
```

Инструкция **ldmxcsr** загружает регистр **MXCSR** из 32-битной переменной. Инструкция **stmxcsr** сохраняет текущее содержимое регистра **MXCSR** в 32-битную переменную. Как правило, данный регистр применяется для установки режима округления.

#

---
# Операции с вещественными числами и векторами

#

## **movq / vmovq / align / ...** - копирование данных

Тут для более эффективного копирования лучше выравнивать данные с помощью **align *число*** 

Для перемещения в **SSE** есть ряд инструкций:

- **movd** - для 32 битных чисел
- **movq** - для 64 битных чисел

```asm
movd xmm, reg32/mem32
movq xmm, reg64/mem64
; или
movd reg32/mem32, xmm
movq reg64/mem64, xmm
; или
movq xmm, xmm
```

**AVX** поддерживает аналогичные инструкции только с припиской **v**

- **vmovd** - для 32 битных чисел
- **vmovq** - для 64 битных чисел

```asm
vmovd xmm, reg32/mem32
vmovq xmm, reg64/mem64
; или
vmovd reg32/mem32, xmm
vmovq reg64/mem64, xmm
; или
vmovq xmm, xmm
```

Для копирования отдельных чисел с плавающей точной есть инструкции в **SSE**

- **movss:** копирует одно 32-разрядное число с плавающей точкой
- **movsd:** копирует одно 64-разрядное число с плавающей точкой

И их аналоги в **AVX**

- **vmovss:** копирует одно 32-разрядное число с плавающей точкой
- **vmovsd:** копирует одно 64-разрядное число с плавающей точкой

Для лучшей эффективности для **movss** переменные должны быть выровнены по 4 битам, а для **movsd** по 8 битам

```asm
(v)movss xmm, mem32
(v)movss mem32, xmm
(v)movss xmm, xmm
(v)movsd xmmn, mem64
(v)movsd mem64, xmm
(v)movsd xmm, xmm
```

Для копирования вектора данные есть два варианта, выровненные и невыровненные

### Копирование выровненных данных

Буква **a** "aligned" (выровненный) 

**SSE**, эти инструкции копируют вектор данных выровненных по 16 байт (нельзя использовать YMM):

- **movaps:** копирование набора 32-разрядных чисел
- **movapd:** копирование набора 64-разрядных чисел
- **movdqa:** копирование восьмеричного слова (128 байт)

**AVX**, эти инструкции копируют вектор данных выровненных по 32 байт (можно использовать YMM):

- **vmovaps:** копирование набора 32-разрядных чисел
- **vmovapd:** копирование набора 64-разрядных чисел
- **vmovdqa:** копирование восьмеричного слова (128 байт)

```asm
(v)movaps mem128, xmm
vmovaps mem256, ymm
(v)movaps xmm, mem128
vmovaps ymm, mem256
(v)movaps xmm, xmm
vmovaps ymm, ymm
(v)movapd mem128, xmm
vmovapd mem256, ymm
(v)movapd xmm, mem128
vmovapd ymm, mem256
(v)movapd xmm, xmm
vmovapd ymm, ymm
(v)movdqa mem128, xmm
vmovdqa mem256, ymm
(v)movdqa xmm, mem128
vmovdqa ymm, mem256
(v)movdqa xmm, xmm
vmovdqa ymm, ymm
```

```asm
.data
    align 16      ; гарантируем выравнивание
    source dd 12, 13, 14, 15    ; откуда копируем
 
.bss
    align 16       ; гарантируем выравнивание
    dest resd 1    ; куда копируем
 
.text
_start:
    movaps xmm0, [source]    ; копируем из source в xmm0
    movaps [dest], xmm0      ; копируем из xmm0 в dest
    mov eax, [dest]       ; rax == 12
```

Аналогично можно копировать любые массивы, в том числе и строки

### Копирование невыровненных данных

Есть аналогичные инструкции только для невыровненных данных, по факту работает медленнее

Буква **u** "unaligned" (невыровненный)

- **(v)movups:** копирование невыровненных 4-байтных чисел (32 бита)
- **(v)movupd:** копирование невыровненных 8-байтных чисел (64 бита)
- **(v)movdqu:** копирование невыровненных 16-байтных чисел (128 бита)

#

---
## Сохранение в стек

Для сохранения в срек использовать push/pop не выйдет тк они выделяют 4 для 32-х битного приложения и 8 для 64-х битного

По этому нам нужно использовать rsp/esp, пример сохранения первых пяти регистров XMM/YMM

```asm
    sub rsp, 192

    movdqu [rsp], xmm0
    movdqu [rsp + 16], xmm1
    movdqu [rsp + 32], xmm2
    movdqu [rsp + 48], xmm3
    movdqu [rsp + 64], xmm4
    movdqu [rsp + 80], xmm5

    vmovdqu [rsp + 0], ymm0
    vmovdqu [rsp + 32], ymm1
    vmovdqu [rsp + 64], ymm2
    vmovdqu [rsp + 96], ymm3
    vmovdqu [rsp + 128], ymm4
    vmovdqu [rsp + 160], ymm5
    
    ; олучение обратно
    
    movdqu xmm0, [rsp] 
    movdqu xmm1, [rsp + 16] 
    movdqu xmm2, [rsp + 32] 
    movdqu xmm3, [rsp + 48] 
    movdqu xmm4, [rsp + 64] 
    movdqu xmm5, [rsp + 80]
    
    vmovdqu ymm0, [rsp + 0]
    vmovdqu ymm1, [rsp + 32]
    vmovdqu ymm2, [rsp + 64]
    vmovdqu ymm3, [rsp + 96]
    vmovdqu ymm4, [rsp + 128]
    vmovdqu ymm5, [rsp + 160]
    
    add rsp, 192
```

#

---
## Преобразование в целые и с плавающей точкой

Можно преобразовывать как обычные числа, так и вектора

### Обычные числа

- **cvtsd2si:** преобразует 64-разрядное число с плавающей точкой в 32- или 64-битное целое число. Для округления применет режим, установленный в регистре MXCSR. Результат сохраняется в 32- или 64-битном регистре общего назначения.

```asm
cvtsd2si reg32/64, xmm/mem64
```

- **cvtsd2ss:** преобразует 64-разрядное число с плавающей точкой (в регистре XMM или переменной) в число 32-разрядное число с плавающей точкой и оставляет результат в втором операнде - регистре XMM. Для округления применет режим, установленный в регистре MXCSR.

```asm
cvtsd2ss xmm, xmm/mem64
```

- **cvtsi2sd:** преобразует 32- или 64-разрядное целое число из регистра общего назначения или переменной в 64-разрядное число с плавающей точкой, оставляя результат в регистре XMM.

```asm
cvtsi2sd xmm, reg32/reg64/mem32/mem64
```

- **cvtsi2ss:** преобразует 32- или 64-разрядное целое число в целочисленном регистре или переменной в 32-разрядное число с плавающей точкой, оставляя результат в регистре XMM.

```asm
cvtsi2ss xmm, reg32/reg64/mem32/mem64
```

- **cvtss2sd:** преобразует 32-разрядное число с плавающей точкой из регистра XMM или переменной в 64-разрядное число с плавающей точкой, оставляя результат в регистре XMM в первом операнде.

```asm
cvtss2sd xmm, xmm/mem32
```

- **cvtss2si:** преобразует 32-разрядное число с плавающей точкой из регистра XMM или переменной в целое число и оставляет результат в 32- или 64-битном регистре общего назначения. Для округления применет режим, установленный в регистре MXCSR.

```asm
cvtss2si reg32/reg64, xmm/mem32
```

- **cvttsd2si:** преобразует 64-разрядное число с плавающей точкой в 32- или 64-битное целое число. Преобразование выполняется с использованием усечения (не использует биты управления округлением в MXCSR). Результат сохраняется в 32- или 64-битном регистре общего назначения.

```asm
cvttsd2si reg32/64, xmm/mem64
```

- **cvttss2si:** преобразует 32-разрядное число с плавающей точкой в 32- или 64-битное целое число. Преобразование выполняется с использованием усечения (не использует биты управления округлением в MXCSR). Результат сохраняется в 32- или 64-битном регистре общего назначения.

```asm
cvttss2si reg32/reg64, xmm/mem32
```

Названия всех инструкций следует определенному шаблону. Например, **cvtsi2sd:** cvt (convert - преобразовать) + s (single - число с плавающей точкой одинарной точности) + i (integer - целое число) + 2 (to - в) + s (scalar - скалярное значение) + d(double - число с плавающей точкой двойной точности).

Для округления используются 13-14 биты регистра состояния **MXCSR:**

- 00: округление до ближайшего
- 01: округление до -бесконечности
- 10: округление до +бесконечности
- 11: округление до 0 (усечение)

По умолчанию округление идет до ближайшего. Так, число 3.4 округляется до 3, а число 3.5 - до 4. Управляя этими битами, можно настроить округление при преобразовании.

```asm
.data
    val dq 123.75
.bss
    tmp dd ?
.code
main:
    stmxcsr [tmp]       ; загружаем регистр в переменную tmp
    or [tmp], 110000000000000b     ; устанавливаем 13 и 14 биты
    ldmxcsr [tmp]     ; сохраняем данные из переменной tmp в регистр

    movsd xmm0, [val]    ; помещаем число number в xmm0
    cvtsd2si rax, xmm0    ; преобразуем число из xmm0 в целое число и помещаем в rdi

    invoke ExitProcess, rax ; rax == 123
```

### Преобразование векторов

- **cvtdq2pd:** преобразует два 32-разрядных целых числа со знаком в два 64-разрядных числа с плавающей точкой

```asm
cvtdq2pd xmmdest, xmmsrc/mem64
````

- **vcvtdq2pd:** преобразует два 32-разрядных целых числа со знаком в два 64-разрядных числа с плавающей точкой (результат в XMM)

```asm
vcvtdq2pd xmmdest, xmmsrc/mem64
```

Либо преобразует четыре 32-разрядных целых числа со знаком в четыре 64-разрядных числа с плавающей точкой (результат в YMM)

```asm
vcvtdq2pd ymmdest, xmmsrc/mem128
```

- **cvtdq2ps:** преобразует 4 32-разрядных целых числа со знаком в 4 32-разрядных числа с плавающей точкой

```asm
cvtdq2ps xmmdest, xmmsrc/mem128
```

- **vcvtdq2ps:** преобразует 4 32-разрядных целых числа со знаком в 4 32-разрядных числа с плавающей точкой

```asm
vcvtdq2ps xmmdest, xmmsrc/mem128
```

Другая форма инструкции преобразует 8 32-разрядных целых числа со знаком в 8 32-разрядных чисел с плавающей точкой

```asm
vcvtdq2ps ymmdest, ymmsrc/mem256
```

- **cvtpd2dq:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных целых числа со знаком

```asm
cvtpd2dq xmmdest, xmmsrc/mem128
```

- **vcvtpd2dq:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных целых числа со знаком (результат в XMM)

```asm
vcvtpd2dq xmmdest, xmmsrc/mem128
```

Другая форма преобразует преобразует 4 64-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
vcvtpd2dq xmmdest, ymmsrc/mem256
```

- **cvtpd2ps:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных числа с плавающей точкой

```asm
cvtpd2ps xmmdest, xmmsrc/mem128
```

- **vcvtpd2ps:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных числа с плавающей точкой

```asm
vcvtpd2ps xmmdest, xmmsrc/mem128
```

Другая форма преобразует преобразует 4 64-разрядных числа с плавающей точкой в 4 32-разрядных числа с плавающей точкой

```asm
vcvtpd2ps xmmdest, ymmsrc/mem256
```

- **cvtps2dq:** преобразует 4 32-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
cvtps2dq xmmdest, xmmsrc/mem128
```

- **vcvtps2dq:** преобразует 4 32-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
vcvtps2dq xmmdest, xmmsrc/mem128
```

Другая форма преобразует 8 32-разрядных числа с плавающей точкой в 8 32-разрядных целых числа со знаком

```asm
vcvtps2dq ymmdest, ymmsrc/mem256
```

- **cvtps2pd:** преобразует два 32-разрядных числа с плавающей точкой в два 64-разрядных числа с плавающей точкой

```asm
cvtps2pd xmmdest, xmmsrc/mem64
```

- **vcvtps2pd:** преобразует два 32-разрядных числа с плавающей точкой в два 64-разрядных числа с плавающей точкой

```asm
vcvtps2pd xmmdest, xmmsrc/mem64
```

Другая форма преобразует 4 32-разрядных числа с плавающей точкой в 4 64-разрядных числа с плавающей точкой

```asm
vcvtps2pd ymmdest, xmmsrc/mem128
```

- **cvttpd2dq:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных целых числа со знаком

```asm
cvttpd2dq xmmdest, xmmsrc/mem128
```

- **vcvttpd2dq:** преобразует два 64-разрядных числа с плавающей точкой в два 32-разрядных целых числа со знаком

```asm
vcvttpd2dq xmmdest, xmmsrc/mem128
```

Другая форма преобразует 4 64-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
vcvttpd2dq xmmdest, ymmsrc/mem256
```

- **cvttps2dq:** преобразует 4 32-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
cvttps2dq xmmdest, xmmsrc/mem128
```

- **vcvttps2dq:** преобразует 4 32-разрядных числа с плавающей точкой в 4 32-разрядных целых числа со знаком

```asm
vcvttps2dq xmmdest, xmmsrc/mem128
```

Другая форма преобразует 8 32-разрядных чисел с плавающей точкой в 8 32-разрядных целых чисел со знаком

```asm
vcvttps2dq ymmdest, ymmsrc/mem256
```

Удобно когда есть массив дробных чисел которые нужно преобразовать в целые числа

```asm
.data
    floadNums dd 1.23, 4.2, 213.23, 123.7
.bss
    intNums dd 4 dep (?)
.code
main:
    cvttps2dq xmm0, [floatNums]  ; преобразуем чисел с плавающей точкой в целые числа, результат помещаем в xmm0
    movaps [intNums], xmm0       ; результат помещаем в intNums
 
    mov edi, [intNums]         ; edi = 1
```

#

---
## Арифметические операции **SSE**

- **addss и addsd:** сложение
- **subss и subsd:** вычитание
- **mulss и mulsd:** умножение
- **divss и divsd:** деление
- **minss и minsd:** вычисляют минимальное значение двух операндов, сохраняя минимальное значение в первом операнде.
- **maxss и maxsd:** вычисляют максимальное значение двух операндов, сохраняя минимальное значение в первом операнде.
- **sqrtss и sqrtsd:** вычисляют квадратный корень второго операнда и сохраняют результат в первый операнд
- **rcpss и rcpsd:** вычисляют обратное значение второго операнда, сохраняя результат в первый операнд
- **rsqrtss и rsqrtsd:** вычисляют обратное значение квадратного корня второго операнда, сохраняя результат в первый операнд

Инструкции, которые оканчиваются на **ss**, предназначены для 32-разрядных чисел с плавающей точкой (ss - сокращение от "scalar single"). 

Инструкции, которые оканчиваются на **sd**, предназначены для 64-разрядных чисел с плавающей точкой (sd - сокращение от "scalar double").

```asm
addss xmm, mem32/xmm
addsd xmm, mem64/xmm
 
subss xmm, mem32/xmm
subsd xmm, mem64/xmm
 
mulss xmm, mem32/xmm
mulsd xmm, mem64/xmm
 
divss xmm, mem32/xmm
divsd xmm, mem64/xmm
 
minss xmm, mem32/xmm
minsd xmm, mem64/xmm
 
maxss xmm, mem32/xmm
maxsd xmm, mem64/xmm

sqrtss xmm, mem32/xmm
sqrtsd xmm, mem64/xmm
 
rcpss xmm, mem32/xmm
rcpsd xmm, mem64/xmm
 
rsqrtss xmm, mem32/xmm
rsqrtsd xmm, mem64/xmm
```
#

---
## Сравнение **SSE**

Инструкции принимают 2 (или 3) параметра, сравнивают их и результат помещается в первый операнд, если **true** то первый операнд весь забиватеся **1**, если **false** то **0**

То есть если копировать результат в обычный регистр, то **true** это **-1**, а **false** это **0**

```asm
cmpss xmmn, xmmm/mem32, imm8
cmpsd xmmn, xmmm/mem64, imm8
 
cmpeqss xmmn, xmmm/mem32       ; операнды равны
cmpeqsd xmmn, xmmm/mem64       ; операнды равны

cmpltss xmmn, xmmm/mem32       ; первый операнд меньше второго
cmpltsd xmmn, xmmm/mem64       ; первый операнд меньше второго

cmpless xmmn, xmmm/mem32       ; первый операнд меньше или равен второму
cmplesd xmmn, xmmm/mem64       ; первый операнд меньше или равен второму

cmpunordss xmmn, xmmm/mem32    ; неупорядоченное сравнение (один из операндов или оба равны NaN)
cmpunordsd xmmn, xmmm/mem64    ; неупорядоченное сравнение (один из операндов или оба равны NaN)

cmpneqss xmmn, xmmm/mem32      ; операнды не равны
cmpneqsd xmmn, xmmm/mem64      ; операнды не равны

cmpnltss xmmn, xmmm/mem32      ; первый операнд НЕ меньше второго
cmpnltsd xmmn, xmmm/mem64      ; первый операнд НЕ меньше второго

cmpnless xmmn, xmmm/mem32      ; первый операнд НЕ меньше или равен второму
cmpnlesd xmmn, xmmm/mem64      ; первый операнд НЕ меньше или равен второму

cmpordss xmmn, xmmm/mem32      ; упорядоченное сравнение
cmpordsd xmmn, xmmm/mem64      ; упорядоченное сравнение
```

Первые две инструкции позволяют 3 параметром передать действие:

- **0:** Первый операнд == второй операнд
- **1:** Первый операнд < второй операнд
- **2:** Первый операнд <= второй операнд
- **3:** Неупорядоченное сравнение
- **4:** Первый операнд ≠ второй операнд
- **5:** Первый операнд >= второй операнд 
- **6:** Первый операнд > второй операнд 
- **7:** Упорядоченное сравнение

```asm
.data
    val dd 12.23
.code
main:
    movsd xmm0, [val]  
    movsd xmm1, [val] 
 
    cmpeqsd xmm0, xmm1      ; проверяем, равны ли операнды
    movq rax, xmm0          ; rax == -1 (true)
    
    test rax, rax ; можно и cmp rax, -1 
    jnz true
true:
    ;...
```

**test** - проверяет, если в двух операндах будет -1, то он не установит флаг нуля ZF

#

---
# Ниже идут операции только (почти) для векторов

#

## Операции сдвига SSE/AVX

Для получения доступа к отдельным элементам в векторе регистров XMM/YMM можно использовать операции сдвига

***ВАЖНО*** операции сдвига сдвигают по **байтам** так что минимум можно сдвинуть **8 разрядов**

- **pslldq:** сдвигает данные в регистре XMM влево на количество байтов, указанное в операнде imm8. В освободившиеся младшие байты помещаются нули.

```asm
pslldq xmmdest, imm8
```

- **vpslldq:** берет значение из второго операнда-регистра XMM или YMM, сдвигает это значение влево на количество байт, указанное в третьем операнде. Затем сохраняет результат в регистре из первого операнда.

```asm
vpslldq xmmdest, xmmsrc, imm8
vpslldq ymmdest, ymmsrc, imm8
```
128-битный вариант инструкция также заполняет нулями биты со 128 по 255 регистра YMM.

- **psrldq:** сдвигает данные в регистре XMM вправо на количество байтов, указанное в операнде imm8. В освободившиеся старшие байты помещаются нули.

```asm
psrldq xmmdest, imm8
```

- **vpsrldq:** сдвигает вправо значение из второго операнда-регистра XMM или YMM на количество байт, указанное в третьем операнде. Затем сохраняет результат в первом операнде.

```asm
vpsrldq xmmdest, xmmsrc, imm8
vpsrldq ymmdest, ymmsrc, imm8
```

```asm
.data
    nums dd 3, 5, 8, 11
 
.code
_start:
    movaps xmm0, [nums]   ; вектор nums в регистр xmm0
    psrldq xmm0, 4        ; сдвигаем регистр xmm0 вправо на 4 байта
    movd edi, xmm0        ; edi == 5
```

    3, 5, 8, 11 << 4 = 5, 8, 11, 0

Так же есть возможность использовать смещение в конкретных элементах

- **(v)psllw:** сдвигает влево слово (16-разрядное целое число)
- **(v)pslld:** сдвигает влево двойное слово (32-разрядное целое число)
- **(v)psllq:** сдвигает влево четверное слово (64-разрядное целое число)
- **(v)psrlw:** сдвигает вправо слово
- **(v)psrld:** сдвигает вправо двойное слово
- **(v)psrlq:** сдвигает вправо четверное слово
- **(v)psraw:** арифметический сдвиг слова вправо
- **(v)psrad:** арифметический сдвиг двойного слова вправо
- **(v)psraq:** арифметический сдвиг четверного слова вправо

Синтаксис для **(v)psllw** (у остальных так же):

```asm
psllw xmm, imm8
psllw xmm, xmm/mem128
vpsllw xmm, xmm, imm8
vpsllw xmm, xmm, mem128
vpsllw ymm, ymm, imm8
vpsllw ymm, ymm, xmm/mem128
```

```asm
.data
    nums dd 1,2,4,8

.code
main:
    movaps xmm0, [nums]     ; вектор num0 в регистр xmm5
 
    pslld xmm0, 1         ; сдвиг влево каждого числа из xmm0
    ; xmm0 == 2,4,8,16
```

#

---
## Логические операции SSE/AVX

Для выполнения этих операций переменные должны быть выровнены по **16 байт для XMM** и по **32 байта для YMM**

Инструкции SSE (без префикса v) оставляют старшие биты в целевом регистре YMM без изменений. Инструкции AVX (с префиксом v), которые имеют 128-битные операнды, заполняют старшие 128 бит регистра YMM нулями

- **andpd:** op1 = op1 & op2 (128-разрядные операнды)
- **vandpd:** op1 = op2 & op3 (128- или 256-разрядные операнды)
- **andnpd:** op1 = op1 & ~op2 (128-разрядные операнды)
- **vandnpd:** op1 = op2 & ~op3 (128- или 256-разрядные операнды)
- **orpd:** op1 = op1 | op2 (128-разрядные операнды)
- **vorpd:** op1 = op2 | op3 (128- или 256-разрядные операнды)
- **xorpd:** op1 = op1 ^ op2 (128-разрядные операнды)
- **vxorpd:** op1 = op2 ^ op3 (128- или 256-разрядные операнды)

```asm
andpd xmmdest, xmmsrc/mem128
vandpd xmmdest, xmmsrc1, xmmsrc2/mem128
vandpd ymmdest, ymmsrc1, ymmsrc2/mem256

andnpd xmmdest, xmmsrc/mem128
vandnpd xmmdest, xmmsrc1, xmmsrc2/mem128
vandnpd ymmdest, ymmsrc1, ymmsrc2/mem256

orpd xmmdest, xmmsrc/mem128
vorpd xmmdest, xmmsrc1, xmmsrc2/mem128
vorpd ymmdest, ymmsrc1, ymmsrc2/mem256

xorpd xmmdest, xmmsrc/mem128
vxorpd xmmdest, xmmsrc1, xmmsrc2/mem128
vxorpd ymmdest, ymmsrc1, ymmsrc2/mem256
```

Пример программы которая выравнивает по нижнему регистру строку

```asm
.data
    f db '%s',10,0
    align 16
    msg db 'HuYTa',0
    sizemsg db ($ - msg - 1)
    align 16
    mask:
        .mask db (sizemsg - msg - 1) dup(00100000b)
        .size db (16 - ($ - .mask)) dup(0)

.code
main:
    movdqa xmm0, xword[msg]
    orpd xmm0, [mask]
    movdqa xword[msg], xmm0

    invoke printf, f, msg ; msg == 'huyta',0

    invoke ExitProcess, 0
```

#

---
## Сложение SSE/AVX

Эти операции имеют недостаток, это то что они не проверяю было ли переполнение и не ставят вообще никаких флагов

- **paddb:** сложение байтов в 16 дорожках
- **vpaddb:** сложение байтов в 16 дорожках (для 128-битной версии) и в 32 дорожках (для 256-битной версии)
- **paddw:** сложение слов (значений .short/.word) в 8 дорожках
- **vpaddw:** сложение слов в 8 дорожках (для 128-битной версии) и в 16 дорожках (для 256-битной версии)
- **paddd:** сложение двойных слов (значений .long) в 4 дорожках
- **vpaddd:** сложение двойных слов в 4 дорожках (для 128-битной версии) и в 8 дорожках (для 256-битной версии)
- **paddq:** сложение четверных слов (тип .quad) в 2 дорожках
- **vpaddq:** сложение четверных слов в 2 дорожках (128-битной версии) и в 4 дорожках (для 256-битной версии)

```asm
paddb xmm, xmm/mem128           ; op1 = op1 + op2
vpaddb xmm, xmm, xmm/mem128     ; op1 = op2 + op3
vpaddb ymm, ymm, ymm/mem256     ; op1 = op2 + op3
 
paddw xmm, xmm/mem128           ; op1 = op1 + op2
vpaddw xmm, xmm, xmm/mem128     ; op1 = op2 + op3
vpaddw ymm, ymm, ymm/mem256     ; op1 = op2 + op3
 
paddd xmm, xmm/mem128           ; op1 = op1 + op2
vpaddd xmm, xmm, xmm/mem128     ; op1 = op2 + op3
vpaddd ymm, ymm, ymm/mem256     ; op1 = op2 + op3
 
paddq xmm, xmm/mem128           ; op1 = op1 + op2
vpaddq xmm, xmm, xmm/mem128     ; op1 = op2 + op3
vpaddq ymm, ymm, ymm/mem256     ; op1 = op2 + op3
```

```asm
.data
    nums0 dd 1,2,3,4
    nums1 dd 5,1,3,2
.code
main:
    movaps xmm0, [nums0]
    movaps xmm1, [nums1]
    paddd xmm0, xmm1    ; xmm0 = xmm0 + xmm1
    ; xmm0 == 6, 3, 6, 6  
```

### Сложение с насыщением

Есть аналоги этих инструкций которые не позволяю данным переполниться и пройти максимальное для них число

При сложении например байтовых чисел будет выглядеть все примерно так 255 + 213 = 255 или -125 - 10 = -128

- **paddsb:** сложение байтов со знаком в 16 дорожках
- **vpaddsb:** сложение байтов со знаком в 16 дорожках
- **vpaddsb:** сложение байтов со знаком в 32 дорожках
- **paddsw:** сложение слов со знаком в 8 дорожках
- **vpaddsw:** сложение слов со знаком в 8 дорожках
- **vpaddsw:** сложение слов со знаком в 16 дорожках
- **paddusb:** сложение беззнаковых байтов в 16 дорожках
- **vpaddusb:** сложение беззнаковых байтов в 16 дорожках
- **vpaddusb:** сложение беззнаковых байтов в 32 дорожках
- **paddusw:** сложение беззнаковых слов в 8 дорожках
- **vpaddusw:** сложение беззнаковых слов в 8 дорожках
- **vpaddusw:** сложение беззнаковых слов в 16 дорожках

Синтаксис аналогичен:

```asm
paddsb xmmdest, xmmsrc/mem128                ; op1 = op1 + op2
vpaddsb xmmdest, xmmsrc1, xmmsrc2/mem128     ; op1 = op2 + op3
vpaddsb ymmdest, ymmsrc1, ymmsrc2/mem256     ; op1 = op2 + op3
 
paddsw xmmdest, xmmsrc/mem128                ; op1 = op1 + op2
vpaddsw xmmdest, xmmsrc1, xmmsrc2/mem128     ; op1 = op2 + op3
vpaddsw ymmdest, ymmsrc1, ymmsrc2/mem256     ; op1 = op2 + op3
 
paddusb xmmdest, xmmsrc/mem128                ; op1 = op1 + op2
vpaddusb xmmdest, xmmsrc1, xmmsrc2/mem128     ; op1 = op2 + op3
vpaddusb ymmdest, ymmsrc1, ymmsrc2/mem256     ; op1 = op2 + op3
 
paddusw xmmdest, xmmsrc/mem128                ; op1 = op1 + op2
vpaddusw xmmdest, xmmsrc1, xmmsrc2/mem128     ; op1 = op2 + op3
vpaddusw ymmdest, ymmsrc1, ymmsrc2/mem256     ; op1 = op2 + op3
```

```asm
.data
    nums0 dd 127,2,3,4
    nums1 dd 5,1,3,2
.code
main:
    movaps xmm0, [nums0]
    movaps xmm1, [nums1]
    paddsd xmm0, xmm1    ; xmm0 = xmm0 + xmm1
    ; xmm0 == 127, 3, 6, 6  
```

### Горизонтальное сложение

Тут суть такова что складываются два ближстоящих числа, и помещаются в результат, потом следующие и так далее

    tmp[0] = x[0] + x[1]
    tmp[1] = x[2] + x[3]
    tmp[2] = y[0] + y[1]
    tmp[3] = y[2] + y[3]
    и тд...    

- **(v)phaddw:** сложение 16-битных чисел
- **(v)phaddd:** сложение 32-битных чисел
- **(v)phaddsw:** сложение 16-битных чисел с насыщением

Синтаксис аналогичен:

```asm
phaddw xmm, xmm/mem128
vphaddw xmm, xmm, xmm/mem128
vphaddw ymm, ymm, ymm/mem256
 
phaddd xmm, xmm/mem128
vphaddd xmm, xmm, xmm/mem128
vphaddd ymm, ymm, ymm/mem256
 
phaddsw xmm, xmm/mem128
vphaddsw xmm, xmm, xmm/mem128
vphaddsw ymm, ymm, ymm/mem256
```

Пример **phaddd**:

    xmm[0-31] = xmmsrc1[0-31] + xmmsrc1[32-63]
    xmm[32-63] = xmmsrc1[64-95] + xmmsrc1[96-127]
    xmm[64-95] = xmmsrc2/mem128[0-31] + xmmsrc2/mem128[32-63]
    xmm[96-127] = xmmsrc2/mem128[64-95] + xmmsrc2/mem128[96-127]

```asm
.data
    tmp1 dd 1,1,2,2
    tmp2 dd 2,3,2,4

.code
main:
    movdqa xmm0, xword[tmp1]
    phaddd xmm0, xword[tmp2]

    movdqa xword[tmp1], xmm0

    invoke printf, f, [tmp1 + 12] ; tmp1 == 2, 4, 5, 6

    invoke ExitProcess, 0
```

#

---
## Вычитание SSE/AVX

Для вычитания есть аналогичные сложению инструкции 

- **psubb:** вычитание байтов в 16 дорожках
- **vpsubb:** вычитание байтов в 16 дорожках (для 128-битной версии) и в 32 дорожках (для 256-битной версии)
- **psubw:** вычитание слов (значений .short/.word) в 8 дорожках
- **vpsubw:** вычитание слов в 8 дорожках (для 128-битной версии) и в 16 дорожках (для 256-битной версии)
- **psubd:** вычитание двойных слов (значений .long) в 4 дорожках
- **vpsubd:** вычитание двойных слов в 4 дорожках (для 128-битной версии) и в 8 дорожках (для 256-битной версии)
- **psubq:** вычитание четверных слов (тип .quad) в 2 дорожках
- **vpsubq:** вычитание четверных слов в 2 дорожках (128-битной версии) и в 4 дорожках (для 256-битной версии)

```asm
psubb xmm, xmm/mem128                ; op1 = op1 - op2
vpsubb xmm, xmm, xmm/mem128     ; op1 = op2 - op3
vpsubb ymm, ymm, ymm/mem256     ; op1 = op2 - op3
 
psubw xmm, xmm/mem128                ; op1 = op1 - op2
vpsubw xmm, xmm, xmm/mem128     ; op1 = op2 - op3
vpsubw ymm, ymm, ymm/mem256     ; op1 = op2 - op3
 
psubd xmm, xmm/mem128                ; op1 = op1 - op2
vpsubd xmm, xmm, xmm/mem128     ; op1 = op2 - op3
vpsubd ymm, ymm, ymm/mem256
 
psubq xmm, xmm/mem128                ; op1 = op1 - op2
vpsubq xmm, xmm, xmm/mem128     ; op1 = op2 - op3
vpsubq ymm, ymm, ymm/mem256     ; op1 = op2 - op3
```

Эти инструкции не влияют ни на какие флаги, так что для них есть аналоги с насыщением

- **psubsb:** вычитание байтов со знаком в 16 дорожках
- **vpsubsb:** вычитание байтов со знаком в 16 дорожках
- **vpsubsb:** вычитание байтов со знаком в 32 дорожках
- **psubsw:** вычитание слов со знаком в 8 дорожках
- **vpsubsw:** вычитание слов со знаком в 8 дорожках
- **vpsubsw:** вычитание слов со знаком в 16 дорожках
- **psubusb:** вычитание беззнаковых байтов в 16 дорожках
- **vpsubusb:** вычитание беззнаковых байтов в 16 дорожках
- **vpsubusb:** вычитание беззнаковых байтов в 32 дорожках
- **psubusw:** вычитание беззнаковых слов в 8 дорожках
- **vpsubusw:** вычитание беззнаковых слов в 8 дорожках
- **vpsubusw:** вычитание беззнаковых слов в 16 дорожках

```asm
psubsb xmm, xmm/mem128
vpsubsb xmm, xmm, xmm/mem128
vpsubsb ymm, ymm, ymm/mem256
 
psubsw xmm, xmm/mem128
vpsubsw xmm, xmm, xmm/mem128
vpsubsw ymm, ymm, ymm/mem256
 
psubusb xmm, xmm/mem128
vpsubusb xmm, xmm, xmm/mem128
vpsubusb ymm, ymm, ymm/mem256
 
psubusw xmm, xmm/mem128
vpsubusw xmm, xmm, xmm/mem128
vpsubusw ymm, ymm, ymm/mem256
```

#

---
## Умножение SSE/AVX

- **pmullw:** перемножает слова (word) из 8 дорожек, младшее слово результата помещается в итоговую дорожку
- **vpmullw:** перемножает слова из 8 дорожек (128-битная версия) или из 16 дорожек (256-битная версия), младшее слово результата помещается в итоговую дорожку
- **pmulhuw:** перемножает беззнаковые слова из 8 дорожек, старшее слово результата помещается в итоговую дорожку
- **vpmulhuw:** перемножает слова из 8 дорожек (128-битная версия) или из 16 дорожек (256-битная версия), старшее слово результата помещается в итоговую дорожку
- **pmulhw:** перемножает слова со знаком из 8 дорожек, старшее слово результата помещается в итоговую дорожку
- **vpmulhw:** перемножает слова из 8 дорожек (128-битная версия) или из 16 дорожек (256-битная версия), старшее слово результата помещается в итоговую дорожку
- **pmulld:** перемножает двойные слова (dword) из 4 дорожек, младшее двойное слово результата помещается в итоговую дорожку
- **vpmulld:** перемножает двойные слова из 4 дорожек (128-битная версия) или из 8 дорожек (256-битная версия), младшее двойное слово результата помещается в итоговую дорожку
- **vpmullq:** перемножает четверные слова (qword) из 2 дорожек (128-битная версия) или из 4 дорожек (256-битная версия), младшее четверное слово результата помещается в итоговую дорожку

```asm
pmullw xmm, xmm/mem128          ; op1 = op1 * op2
vpmullw xmm, xmm, xmm/mem128    ; op1 = op2 * op3
vpmullw ymm, ymm, ymm/mem256    ; op1 = op2 * op3
 
pmulhuw xmm, xmm/mem128         ; op1 = op1 * op2
vpmulhuw xmm, xmm, xmm/mem128    ; op1 = op2 * op3
vpmulhuw ymm, ymm, ymm/mem256    ; op1 = op2 * op3
    
pmulhw xmm, xmm/mem128          ; op1 = op1 * op2
vpmulhw xmm, xmm, xmm/mem128    ; op1 = op2 * op3
vpmulhw ymm, ymm, ymm/mem256    ; op1 = op2 * op3
 
pmulld xmm, xmm/mem128          ; op1 = op1 * op2
vpmulld xmm, xmm, xmm/mem128    ; op1 = op2 * op3
vpmulld ymm, ymm, ymm/mem256    ; op1 = op2 * op3
 
vpmullq xmm, xmm, xmm/mem128    ; op1 = op2 * op3
vpmullq ymm, ymm, ymm/mem256    ; op1 = op2 * op3
```

Проблема подобного умножения то что происходит умножение чисел n-разрядности и записывается в n-разрядный регистр, а должны в 2n, из-за этого может быть переполнение

Есть некое решение для этого:

- **pmuldq:** умножает двойные слова (dword) со знаком в 32-битных дорожках 0 и 2 и сохраняет 64-битные результаты в 64-битных дорожках 0 и 1 (они же 32-битные дорожки 0, 1, 2 и 3). Старшие 128 бит перекрывающего регистра YMM остаются без изменений
- **pmuludq:** умножает беззнаковые двойные слова в 32-битных дорожках 0 и 2 и сохраняет 64-битные результаты в 64-битных дорожках 0 и 1 (они же 32-битные дорожки 0, 1, 2 и 3). Старшие 128 бит перекрывающего регистра YMM остаются без изменений
- **vpmuldq:** 256-битные варианты умножает двойные слова со знаком в 32-битных дорожках 0, 2, 4, 6 и сохраняет 64-битные результаты в 64-битных дорожках 0, 1, 2 и 3 . 128-битная версия аналогична pmuldq за тем исключением, что старшие 128 бит перекрывающего регистра YMM заполняются нулями
- **vpmuludq:** 256-битные варианты умножает беззнаковые двойные слова в 32-битных дорожках 0, 2, 4, 6 и сохраняет 64-битные результаты в 64-битных дорожках 0, 1, 2 и 3. 128-битная версия аналогична pmuludq за тем исключением, что старшие 128 бит перекрывающего регистра YMM заполняются нулями

```asm
pmuldq xmm, xmm/mem128
vpmuldq xmm, xmm, xmm/mem128
vpmuldq ymm, ymm, ymm/mem256
 
pmuludq xmm, xmm/mem128
vpmuludq xmm, xmm, xmm/mem128
vpmuludq ymm, ymm, ymm/mem256
```

- **(v)pclmulqdq** - умножают четверные слова (qword) и сохраняют 128-битныq результат. **pclmulqdq** оставляет старшие 128 бит перекрывающего регистра YMM без изменений, а **vpclmulqdq** заполняет их нулями.

```asm
pclmulqdq xmm, xmm/mem128, imm8
vpclmulqdq xmm, xmm, xmm/mem128, imm8
```

Операнд **imm**8 указывает, какие четверные слова использовать в качестве исходных операндов. На примере pclmulqdq:

    0x00 | xmm = xmm[0-63] * xmm/mem128[0-63]
    0x01 | xmm = xmm[64-127] * xmm/mem128[0-63]
    0x10 | xmm = xmm[0-63] * xmm/mem128[64-127]
    0x11 | xmm = xmm[64-127] * xmm/mem128[64-127]

#

---
## Математические операции SSE/AVX

### Среднее значение

Эти инструкции вычисляют среднее значение и если оно дробное, то округляют его

- **(v)pavgb** - для байт
- **(v)pavgw** - для слов

```asm
pavgb xmm, xmm/mem128
vpavgb xmm, xmm, xmm/mem128
vpavgb ymm, ymm, ymm/mem256

pavgw xmm, xmm/mem128
vpavgw xmm, xmm, xmm/mem128
vpavgw ymm, ymm, ymm/mem256
```

### Максимальное и минимальное значения


- **(v)pmaxsb**: выбирает максимальное однобайтовое число со знаком из соответствующих дорожек операндов.
- **(v)pmaxsw**: выбирает максимальное 16-битное число со знаком из соответствующих дорожек операндов.
- **(v)pmaxsd**: выбирает максимальное 32-битное число со знаком (sdword).
- **vpmaxsq:** выбирает максимальное 64-битное число со знаком.
- **(v)pmaxub**: выбирает максимальное беззнаковое 8-битное число из соответствующих дорожек операндов.
- **(v)pmaxuw**: выбирает максимальное беззнаковое 16-битное число.
- **(v)pmaxud**: выбирает максимальное беззнаковое 32-битное число.
- **vpmaxuq:** выбирает максимальное беззнаковое 64-битное число.
- **(v)pminsb**: выбирает минимальное однобайтовое число со знаком из соответствующих дорожек операндов.
- **(v)pminsw**: выбирает минимальное 16-битное число со знаком из соответствующих дорожек операндов.
- **(v)pminsd**: выбирает минимальное 32-битное число со знаком (sdword).
- **vpminsq:** выбирает минимальное 64-битное число со знаком.
- **(v)pminub**: выбирает минимальное беззнаковое 8-битное число из соответствующих дорожек операндов.
- **(v)pminuw**: выбирает минимальное беззнаковое 16-битное число.
- **(v)pminud**: выбирает минимальное беззнаковое 32-битное число.
- **vpminuq:** выбирает минимальное беззнаковое 64-битное число.

Общий синтаксис одинаковый, вот пример на **(v)pmaxuw**:

```asm
pmaxuw xmm, xmm/mem128
vpmaxuw xmm, xmm, xmm/mem128
vpmaxuw ymm, ymm, ymm/mem256
```

## Абсолютное значение

- **(v)pabsb** - для байтов
- **(v)pabsw** - для слов 
- **(v)pabsd** - для двойных слов

```asm
pabsb xmm, xmm/mem128
vpabsb xmm, xmm/mem128
vpabsb ymm, ymm/mem256
 
pabsw xmm, xmm/mem128
vpabsw xmm, xmm/mem128
vpabsw ymm, ymm/mem256
 
pabsd xmm, xmm/mem128
vpabsd xmm, xmm/mem128
vpabsd ymm, ymm/mem256
```

## Сравнение целых чисел в векторах SSE/AVX

Механика сравнения схожа с сравнением не векторов, то есть результатом в дорожке будет либо **-1 (true)** либо **0 (false)**

Это удобно использовать для сравнения строк и манипуляций ими, там масочки всякие юзать

Инструкции с припиской **v** сравнивают второй и третий операнд, результат записывают в первый 

Проверяет на равенство:

- **(v)pcmpeqb** - для байт
- **(v)pcmpeqw** - для слов
- **(v)pcmpeqd** - для двойных слов
- **(v)pcmpeqq** - для четверных слов

```asm
pcmpeqb xmmdest, xmmsrc/mem128 ; сравнивает 16 байтовых дорожек
pcmpeqw xmmdest, xmmsrc/mem128 ; сравнивает 8 дорожек с числами word
pcmpeqd xmmdest, xmmsrc/mem128 ; сравнивает 4 дорожек с числами dword
pcmpeqq xmmdest, xmmsrc/mem128 ; сравнивает 2 дорожек с числами qword

vpcmpeqb xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает байты в 16 дорожках
vpcmpeqw xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа word в 8 дорожках
vpcmpeqd xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа dword в 4 дорожках
vpcmpeqq xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа qword в 2 дорожках
 
vpcmpeqb ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает байты в 32 дорожках
vpcmpeqw ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа word в 16 дорожках
vpcmpeqd ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа dword в 8 дорожках
vpcmpeqq ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа qword в 4 дорожках
```

Проверяет больше ли первый операнд чем второй:

- **(v)pcmpgtb** - для байт
- **(v)pcmpgtw** - для слов
- **(v)pcmpgtd** - для двойных слов
- **(v)pcmpgtq** - для четверных слов

```asm
pcmpgtb xmmdest, xmmsrc/mem128 ; сравнивает байты в 16 дорожках
pcmpgtw xmmdest, xmmsrc/mem128 ; сравнивает числа word в 8 дорожках
pcmpgtd xmmdest, xmmsrc/mem128 ; сравнивает числа dword в 4 дорожках
pcmpgtq xmmdest, xmmsrc/mem128 ; сравнивает числа qword в 2 дорожках

vpcmpgtb xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает байты в 16 дорожках
vpcmpgtw xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа word в 8 дорожках
vpcmpgtd xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа dword в 4 дорожках
vpcmpgtq xmmdest, xmmsrc1, xmmsrc2/mem128 ; сравнивает числа qword в 2 дорожках
 
vpcmpgtb ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает байты в 32 дорожках
vpcmpgtw ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа word в 16 дорожках
vpcmpgtd ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа dword в 8 дорожках
vpcmpgtq ymmdest, ymmsrc1, ymmsrc2/mem256 ; сравнивает числа qword в 4 дорожках
```

```asm
.data
    nums0 dd 1, 2, 4, 8 
    nums1 dd 1, 2, 3, 8

.code
main:
    movaps xmm0, [nums0]
    movaps xmm1, [nums1]
    pcmpeqd xmm0, xmm1       ; XMM0 = XMM0 == XMM1
    ; XMM0 = -1, -1, 0, -1
```

Для проверки результат можно использовать **(v)pmovmskb**, он сохраняет старший бит каждого байта, и передает это в регистр 16 (для XMM) и 32 (для YMM) 

```asm
pmovmskb reg, xmm
vpmovmskb reg, xmm
vpmovmskb reg, ymm
```

#

---
## Арифмитические операции для векторов с плавующей точкой

Тут различные операции для векторов с числами с плавающими точками

- **addps:** складывает 4 дорожки операндов с 32-разрядными числами с плавающей точкой
- **addpd:** складывает 2 дорожки операндов с 64-разрядными числами с плавающей точкой
- **vaddps:** складывает 4 дорожки (128-битная версия) или 8 дорожек (256-битная версия) с 32-разрядными числами с плавающей точкой
- **vaddpd:** складывает 2 дорожки (128-битная версия) или 4 дорожки (256-битная версия) с 64-разрядными числами с плавающей точкой
- **subps:** вычитает 4 дорожки операндов с 32-разрядными числами с плавающей точкой
- **subpd:** вычитает 2 дорожки операндов с 64-разрядными числами с плавающей точкой
- **vsubps:** вычитает 4 дорожки (128-битная версия) или 8 дорожек (256-битная версия) с 32-разрядными числами с плавающей точкой
- **vsubpd:** вычитает 2 дорожки (128-битная версия) или 4 дорожки (256-битная версия) с 64-разрядными числами с плавающей точкой
- **mulps:** перемножает 4 дорожки операндов с 32-разрядными числами с плавающей точкой
- **mulpd:** перемножает 2 дорожки операндов с 64-разрядными числами с плавающей точкой
- **vmulps:** перемножает 4 дорожки (128-битная версия) или 8 дорожек (256-битная версия) с 32-разрядными числами с плавающей точкой
- **vmulpd:** перемножает 2 дорожки (128-битная версия) или 4 дорожки (256-битная версия) с 64-разрядными числами с плавающей точкой
- **divps:** делит 4 дорожки операндов с 32-разрядными числами с плавающей точкой
- **divpd:** делит 2 дорожки операндов с 64-разрядными числами с плавающей точкой
- **vdivps:** делит 4 дорожки (128-битная версия) или 8 дорожек (256-битная версия) с 32-разрядными числами с плавающей точкой
- **vdivpd:** делит 2 дорожки (128-битная версия) или 4 дорожки (256-битная версия) с 64-разрядными числами с плавающей точкой
- **maxps:** вычисляет максимальное в каждой из 4 пар чисел с плавающей точкой одинарной точности
- **maxpd:** вычисляет максимальное в каждой из 2 пар чисел с плавающей точкой двойной точности
- **vmaxps:** вычисляет максимальное в каждой из 4 (для 128-битной версии) или 8 (для 256-битной версии) пар чисел с плавающей точкой одинарной точности
- **vmaxpd:** вычисляет максимальное в каждой из 2 (для 128-битной версии) или 4 (для 256-битной версии) пар чисел с плавающей точкой двойной точности
- **minps:** вычисляет минимальное в каждой из 4 пар чисел с плавающей точкой одинарной точности
- **minpd:** вычисляет минимальное в каждой из 2 пар чисел с плавающей точкой двойной точности
- **vminps:** вычисляет минимальное в каждой из 4 (для 128-битной версии) или 8 (для 256-битной версии) пар чисел с плавающей точкой одинарной точности
- **vminpd:** вычисляет минимальное в каждой из 2 (для 128-битной версии) или 4 (для 256-битной версии) пар чисел с плавающей точкой двойной точности
- **sqrtps:** вычисляет квадратный корень для каждого из 4 чисел с плавающей точкой одинарной точности
- **sqrtpd:** вычисляет квадратный корень для 2 чисел с плавающей точкой двойной точности
- **vsqrtps:** вычисляет квадратный корень для каждого из 4 (для 128-битной версии) или 8 (для 256-битной версии) чисел с плавающей точкой одинарной точности
- **vsqrtpd:** вычисляет квадратный корень для каждого из 2 (для 128-битной версии) или 4 (для 256-битной версии) чисел с плавающей точкой двойной точности
- **rsqrtps:** вычисляет приблизительно обратный квадратный корень для каждого из 4 чисел с плавающей точкой одинарной точности
- **vrsqrtps:** вычисляет приблизительно обратный квадратный корень для каждого из 4 (для 128-битной версии) или 8 (для 256-битной версии) чисел с плавающей точкой одинарной точности

Общий синтаксис инструкций на примере (v)addps:

```asm
addps xmmdest, xmmsrc/mem128

vaddps xmmdest, xmmsrc1, xmmsrc2/mem128
vaddps ymmdest, ymmsrc1, ymmsrc2/mem256
```

Инструкции вычисления квадратного корня принимают один операнд:

```asm
sqrtps xmmdest, xmmsrc/mem128

vsqrtps xmmdest, xmmsrc/mem128
vsqrtps ymmdest, ymmsrc/mem256
```

