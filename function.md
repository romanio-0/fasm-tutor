## Функции

Функции в обычном ассемблере это по факту просто метка которая в конце вызывает **ret** и возвращается обратно

```asm
start:
    call foo
    invoke ExitProcess, 0
foo:
    mov eax, 1
    ret    
```

Возвращаемое значение записывается в **rax/eax**

Функция может использовать те же самые глобальные переменные, прыгать по тем же меткам и использовать те же самые регистры

При вызове функции адрес на возврат обратно кладется в стек и на него указывает **esp**, и при вызове **ret** вызывается этот адрес

Важно чтобы при вызове **ret** адрес возврата был на верхушке стека иначе возвратиться не выйдет, но тк это по факту адрес по нему можно перейти и самому

```asm
start:
    call foo
    invoke ExitProcess, eax ; eax == 1
    
foo:
    mov eax, 1
    jmp dword[esp]
    mov eax, 2 ; не выполнится
    ret
```

## сохранение регистров

Для того чтобы вы могли использовать регистры и значение в них не менялось ничего волшебного нет, единственное это где-то их сохранить, например в стеке, и не важно это сделает вызывающая функция и вызываемая

```asm
start:
    mov edx, 1
    call foo
    invoke ExitProcess, edx ; edx == 1
 foo:
    push edx
    mov edx, 123
    ;... что-то происходит
    pop edx
    rat
```

## **enter / leave** - Локальные данные и фрейм стека

Вызывающий код должен подготовить для функции все нужные регистры и передать все что нужно в стек, а после вызова положить адрес возврата в стек, остальное уже делает вызываемая функция

Как таковых локальных переменных в ассемблере нет, но их можно сделать искуственно используя стек и регистр **rbp/ebp**

То есть по факту в стеке у нас храниться адрес возврата, а остальное место все наше, мы можем закинуть в стек регистр **rbp** для того чтобы сохранить значение которое там было до нас, а потом перемещаем туда значение **rsp** теперь **rbp** указывает на начало нашего стека который можно юзать

Потом мы выделяем нужное кол-во памяти в стеке и юзаем используя **rbp** как точку отчета

И незабываем все вернуть назад

```asm
main:
    mov rcx, 5
    mov rdx, 4
    call foo
    invoke ExitProcess, rax ; rax == 9

foo:
    push rbp
    mov rbp, rsp
    sub rsp, 8

    mov dword[rbp - 4], ecx ; 1 переменная в 4 байта
    mov dword[rbp - 8], edx ; 2 переменная в 4 байта

    mov eax, dword[rbp - 4]
    add eax, dword[rbp - 8]

    mov rsp, rbp
    pop rbp
    ret
```

Для того чтобы это каждый раз не писать можно юзать **enter** и **leave**

```asm
main:
    mov rcx, 5
    mov rdx, 4
    call foo
    invoke ExitProcess, rax ; rax == 9

foo:
    enter 8, 0 ; сохраняем значение и выделяем память

    mov dword[rbp - 4], ecx ; 1 переменная в 4 байта
    mov dword[rbp - 8], edx ; 2 переменная в 4 байта

    mov eax, dword[rbp - 4]
    add eax, dword[rbp - 8]

    leave ; востонавливаем значение
    ret
```

## локальные метки

Для того чтобы не париться с названиями можно использовать локальные метки, для них нужно поставить в начале точку

```asm
main:
    mov eax, 1
    jmp .exit ; тупой пример но все же
.exit:
    invoke ExitProcess, rax

foo:
    mov eax, 2
    jmp .exit
.exit:
    ret
```

По факту с технической стороны тут суть такая что у метки становится название **имя_функции.метка** и все

## Передача параметров в Windows

Для передачи параметров в своих функциях можно юзать что угодно, но для вызова функций Си и прочих языков в windows есть соглашение

Для 32 битных приожений все параметры передаются через стек (в стек последний параметр передается первым)

А для 64 битного приложения все сложнее

Параметры передаются так:

- **rcx** / **xmm0**
- **rdx** / **xmm1**
- **r8** / **xmm2**
- **r9** / **xmm3**
- **стек** / **xmmX**

То есть для передачи параметров используются сначала регистры, а если параметров больше 4 то еще и стек (в стек последний параметр передается первым)

Так же при вызове функции, **rsp** тобишь стек должен быть выделен 32 байта и кратен 16, то есть при вызове у нас адрес возврата кладется в стек и забивается 8 байт, и получается 40, а дожно быть кратно 16, так что бы выделяем не 32, а 40 чтобы потом было 48

```asm
main:
.data
    message db 'huy',0
    name db 'lox'0
    age dq 12
    company db 'nihuya',0
    salary dq 123
    
.code
    sub rsp, 40            ; выравнивание должно быть по 16 байтам
    mov rcx, message       ; первый параметр функции printf - строка форматирования
    mov rdx, name          ; первый аргумент для строки форматирования
    mov r8, [age]          ; второй аргумент для строки форматирования
    mov r9, company        ; третий аргумент для строки форматирования
    mov r10, [salary]
    mov qword [rsp+32], r10        ; четвертый аргумент для строки форматирования
    call [printf]
    add rsp, 40              ; восстанавливаем стек
    ret
```

Либо

```asm
main:
.data
    message db 'huy',0
    name db 'lox'0
    age dq 12
    company db 'nihuya',0
    salary dq 123
    
.code
    mov rcx, message       ; первый параметр функции printf - строка форматирования
    mov rdx, name          ; первый аргумент для строки форматирования
    mov r8, [age]          ; второй аргумент для строки форматирования
    mov r9, company        ; третий аргумент для строки форматирования
    push [salary]       ; четвертый аргумент для строки форматирования
    sub rsp, 32       ; 32 тк мы уже запушили 8 байт и выло выравниваение в 40
    call [printf]
    add rsp, 40              ; восстанавливаем стек
    ret
```

### Теория Windwos API

- Вызывающий код передает первые четыре параметра в регистры. Для передачи в функцию первых четырех параметров (целочисленных) используются регистры RCX, RDX, R8 и R9 соответственно. Если параметры представляют числа с плавающей точкой, то они передаются через регистры XMM0, XMM1, XMM2 и XMM3 и дублируются в соответствующих регистрах RCX/RDX/R8/R9. То есть например, если второй параметр представляет число с плавающей точкой, то оно помещается в XMM1 и дублируется в RDX.

- Параметры начиная с 5-го передаются через стек. Так, 5-й параметр должен занимать в стеке место по адресу RSP+32, 6-й параметр - по адресу RSP+40 и так далее.

- Если процедура имеет смешанные параметры - одновременно и целочисленные, и с плавающей запятой, то каждый параметр помещается в соответствующий его номеру регистр RCX/RDX/R8/R9 или XMM0/XMM1/XMM2/XMM3. Например, если у нас есть следующая функция C/C++

```c
void someFunc(int a, double b, char *c, double d)
```
то параметры будут размещаться следуюшим образом
    
    RCX 	   | a
    XMM1 и RDX | b
    R8         | c
    XMM3 и R9  | d

- Параметры всегда представляют собой 8-байтовые значения.

- Вызывающий код должен зарезервировать для параметров в стеке как минимум 32 байта, даже если параметров меньше четырех - это так называемое shadow storage или теневое хранилище. Условно можно сказать, что первый параметр занимает в стеке память по адресу RSP, второй - по адресу RSP+8, третий - RSP+16, четвертный - RSP+24. Но в реальности это хранидище можно использовать для своих целей, например, как место хранения локальных переменных

- Указатель стека RSP должен быть выровнен по 16 байтам непосредственно перед тем, как инструкция call поместит адрес возврата в стек.

- Регистры в Microsot Windows ABI делятся на две группы:
    Volatile-регистры (изменяемые регистры) - они могут изменять свои значения, и функции/процедуре не нужно сохранять значения этих регистров при вызове другой функции/процедуры. Это такие регистры как RAX, RCX, RDX, R8, R9, R10 и R11, а также XMM0/YMM0 – XMM5/YMM5
    Nonvolatile-регистры (неизменяемые регистры) - они должны сохранять информацию при вызове функций/процедур. Поэтому процедура/функция должна сохранять значения этих регистров во время вызова. Если процедура изменяет один из этих регистров, она должна сохранить значение регистра перед первой такой модификацией и восстановить значение регистра из сохраненного местоположения перед возвратом. Это такие регистры как RBX, RBP, RDI, RSI, RSP, R12, R13, R14 и R15, а также XMM6/YMM6 - XMM15/YMM16 (старшую половину регистра YMM6-YMM16 можно изменить)

- Если функция возвращает целое число, то оно помещается в регистр RAX, если число с плавающей точкой - то в регистр XMM0.
