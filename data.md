## Типы данных

Определение типа:

- **db (define byte):** определяет целое число размером в 1 байт
- **dw/du (define word/unicode):** определяет целое число размером в 2 байта (слово)
- **dd (define dword):** определяет целое число размером в 4 байта (так называемое двойное слово)
- **df/dp (reserve fword/pword):** определяет целое число размером в 6 байт
- **dq (define qword/quad):** определяет целое число размером в 8 байт (четверное слово)

Для дробных:

- **dt (define tword):** определяет целое число размером в 10 байт 
- **do (define oword):** определяет целое число размером в 16 байт 
- **dy (define yword):** определяет целое число размером в 32 байт 
- **dz (define zword):** определяет целое число размером в 64 байт 

Резервирование типа (также как определение только начинается с **r**):

- **rb (reserve byte):** резервирует какое-то кол-во данных размером в 1 байт
- **rw/ru (reserve word/unicode):** резервирует какое-то кол-во данных размером в 2 байта (слово)
- **rd (reserve dword):** резервирует какое-то кол-во данных размером в 4 байта (так называемое двойное слово)
- **rf/rp (reserve fword/pword):** резервирует какое-то кол-во данных размером в 6 байт
- **rq (reserve qword/quad):** резервирует какое-то кол-во данных размером в 8 байт (четверное слово)
- и тд для дробных...

**equ** - при указание его при определении, это будет просто аналогом #define, объявляются они в любой части программы 

### Список вообще всех типов

    | name    | bit | byte |
    ------------------------
    | byte    | 8   | 1    |
    | word    | 16  | 2    |
    | dword   | 32  | 4    |
    | fword   | 48  | 6    |
    | pword   | 48  | 6    |
    | qword   | 64  | 8    |
    | tbyte   | 80  | 10   |
    | tword   | 80  | 10   |
    | dqword  | 128 | 16   |
    | xword   | 128 | 16   |
    | qqword  | 256 | 32   |
    | yword   | 256 | 32   |
    | dqqword | 512 | 64   |
    | zword   | 512 | 64   |

---
## Определение данных (переменные)

Для создания пременной есть специальная секция .data, но объявлять переменные можно и в секции с котом, только их нельзя будет менять если в секции с кодом не указанно что разрешена запись

Так же есть другие секции:

- **.bss** - содержит не инициализированные данные, позволяет уменьшить файл и инициализировать уже в памяти
- **.rodata** - содержит данные которые нельзя изменять, так называемые константы

Пример инициализации:

(Для создания секций на fasm используется малость другой принцип)

**Инициализированные данные располагаются по порядку, так что выйдя за переделы мы будем обращаться к ним

```asm
section .data
    val dd 1234 ; переменная val размером 4 байта
    arr rd 5 ; массив на 5 элементов
    
section .rodata
    val2 db 122 ; переменная val2 размером 1 байт
    arr2 rd 5 ; массив на 5 элементов
    
   
section .bss 
    val3 dd ?
    arr3 dd 5 dup(?) ; массив на 5 элементов
```

Тк при простом обращении к переменной мы получим адрес данных, для обращения именно к ним нужно поместить переменную в квадратные скобки

Для преобразования типа данных используется в начале приписка к какому типу нужно преобразовать

```asm
.data
    val dd 123
.code
    mov ex, word[val]
```

Для инициализации массива используется:

```asm
arr1 db 1,2,3,4 ; массив на 4 элемента
arr2 rb 4 ; массив на 4 элемента забитый нулями
arr3 db 4 dup (?) ; массив на 4 элемент, пустой (нулями)
```

---
## Адреса, lea и $ 

Для перемещения по массиву и вообще любым адресам мы используем всю туже арифметику указателей, ведь имя переменной это адрес, а квадратные скобки оператор разыменования

```asm
.data
    val dd 1234
    arr dd 1,2,3,4,5
    
.code1 ; пример 1
    mov eax, [arr] ; eax == 1
    mov eax, [arr + 4] ; eax == 2
    mov eax, [arr + 12] ; eax == 4
    
.code2 ; пример 2
    mov eax, arr ; теперь eax указывает на то же место что и arr
    mov ebx, [eax + 4] ; ebx == 2

.code3 ; пример 3
    mov eax, arr
    mov ebx, 3
    mov edx, [eax + (ebx * 4)] ; edx == 4
    mov edx, [eax + (ebx * 4) + 4] ; edx == 5
    
.code4 
    mov eax, [arr - 4] ; eax == 1234 ))))
```

Тут по факту проблем быть не должно)

**lea** - эта команда схожа с **mov** но отличие в том что она принимает разименованный адрес, а отдает чистый адрес, что позволяет сначала провести все операции и сразу же передать адрес

```asm
.data
    val dd 1,2,3,4,5
.code
    lea eax, [val + 4] ; eax == адрес на 2
    mov ebx, [eax] ; ebx == 2
```

**$** - используется для получения текущего адреса

```asm
.data
    val dd $ ; val хранит свой же адрес
```

```asm
.data
    val rd 10
    size db ($ - val) / 4 ; size хранит колличесто элементов в массиве val
```

---
## Символы и строки

Строки тут просто тот же массив символов

      9| 09 | 00001001 | \t|
     10| 0A | 00001010 | \n|
     32| 20 | 00100000 |   | (пробел)
     33| 21 | 00100001 | ! |
     34| 22 | 00100010 | " |
     35| 23 | 00100011 | # |
     36| 24 | 00100100 | $ |
     37| 25 | 00100101 | % |
     38| 26 | 00100110 | & |
     39| 27 | 00100111 | ' |
     40| 28 | 00101000 | ( |
     41| 29 | 00101001 | ) |
     42| 2a | 00101010 | * |
     43| 2b | 00101011 | + |
     44| 2c | 00101100 | , |
     45| 2d | 00101101 | - |
     46| 2e | 00101110 | . |
     47| 2f | 00101111 | / |
     48| 30 | 00110000 | 0 |
     49| 31 | 00110001 | 1 |
     50| 32 | 00110010 | 2 |
     51| 33 | 00110011 | 3 |
     52| 34 | 00110100 | 4 |
     53| 35 | 00110101 | 5 |
     54| 36 | 00110110 | 6 |
     55| 37 | 00110111 | 7 |
     56| 38 | 00111000 | 8 |
     57| 39 | 00111001 | 9 |
     58| 3a | 00111010 | : |
     59| 3b | 00111011 | ; |
     60| 3c | 00111100 | < |
     61| 3d | 00111101 | = |
     62| 3e | 00111110 | > |
     63| 3f | 00111111 | ? |
     64| 40 | 01000000 | @ |
     65| 41 | 01000001 | A |
     66| 42 | 01000010 | B |
     67| 43 | 01000011 | C |
     68| 44 | 01000100 | D |
     69| 45 | 01000101 | E |
     70| 46 | 01000110 | F |
     71| 47 | 01000111 | G |
     72| 48 | 01001000 | H |
     73| 49 | 01001001 | I |
     74| 4a | 01001010 | J |
     75| 4b | 01001011 | K |
     76| 4c | 01001100 | L |
     77| 4d | 01001101 | M |
     78| 4e | 01001110 | N |
     79| 4f | 01001111 | O |
     80| 50 | 01010000 | P |
     81| 51 | 01010001 | Q |
     82| 52 | 01010010 | R |
     83| 53 | 01010011 | S |
     84| 54 | 01010100 | T |
     85| 55 | 01010101 | U |
     86| 56 | 01010110 | V |
     87| 57 | 01010111 | W |
     88| 58 | 01011000 | X |
     89| 59 | 01011001 | Y |
     90| 5a | 01011010 | Z |
     91| 5b | 01011011 | [ |
     92| 5c | 01011100 | \ |
     93| 5d | 01011101 | ] |
     94| 5e | 01011110 | ^ |
     95| 5f | 01011111 | _ |
     96| 60 | 01100000 | ` |
     97| 61 | 01100001 | a |
     98| 62 | 01100010 | b |
     99| 63 | 01100011 | c |
    100| 64 | 01100100 | d |
    101| 65 | 01100101 | e |
    102| 66 | 01100110 | f |
    103| 67 | 01100111 | g |
    104| 68 | 01101000 | h |
    105| 69 | 01101001 | i |
    106| 6a | 01101010 | j |
    107| 6b | 01101011 | k |
    108| 6c | 01101100 | l |
    109| 6d | 01101101 | m |
    110| 6e | 01101110 | n |
    111| 6f | 01101111 | o |
    112| 70 | 01110000 | p |
    113| 71 | 01110001 | q |
    114| 72 | 01110010 | r |
    115| 73 | 01110011 | s |
    116| 74 | 01110100 | t |
    117| 75 | 01110101 | u |
    118| 76 | 01110110 | v |
    119| 77 | 01110111 | w |
    120| 78 | 01111000 | x |
    121| 79 | 01111001 | y |
    122| 7a | 01111010 | z |
    123| 7b | 01111011 | { |
    124| 7c | 01111100 | | |
    125| 7d | 01111101 | } |
    126| 7e | 01111110 | ~ |
    127| 7f | 01111111 | ⌂ |

```asm
mov eax, 'a' ; eax == 97
mov eax, 'A' ; eax == 65
mov eax, '1' ; eax == 49
```

Тк разница между большими буквами и маленькими наличие однерки в 6 разряде для смены регистра можно просто убрать или добавить там 1

'A' == 01000001 | 'a' == 01100001

'1' == 00110001 | 1  == 00000001

```asm
mov eax, '1'
and eax, 0xf ; eax == 1 тк 00110001 & 00001111 == 00000001
or eax, 00110000b ; eax == '1' 
```

```asm
mov eax, 'A'
xor eax, 00100000b ; eax == 'a'
xor eax, 00100000b ; eax == 'A'
```

Для объявления строки можно использовать несколько способов

```asm
.data
    msg1 db 'l', 'o', 'x', 0 ; нак нуля тут впринципе не обязателен, но для вызова Си-шных функций нужен
    msg2 db 'ne lox',0
```

---
## Структуры

Для обычного ассемблера нет как таковых структур, есть лишь подобие, структура тут это просто набор данных которые идут по порядку и для получения этик данных нужно использовать смещение

```asm
.data
    lol:
        db 122
        dd 2134123
        db 'lox',0
.code
    movsx eax, byte[lol] ; eax == 122
    mov eax, dowrd[lol + 1] ; eax == 2134123
    lea eax, [lol + 5] ; eax == 'lox',0
```

Можно для смещения использовать константы, а строки объявлять в другом месте

```asm
.data
    lol:
        dd name ; размер указателя зависит от разрядности программы
        db 17
        
    name db 'Romick',0
    
    NAME_OF equ 0
    AGE_OF equ 1

.code
    mov eax, dowrd[lol] ; eax == 'Romick',0
    movsx eax, byte[lol + AGE_OF] ; eax == 17
```

**Но** на fasm есть удобные макросы

```asm
.data
    lol:
        .name db 'romka',0 ; важно указывать точку
        .age db 17
        
.code
    mov eax, lol.name ; eax == romka,0
    mov eax, [lol.age] ; eax == 17
```

---
## rsp / push / pop - стек

Для работы со стеком есть специальный регистр, он указывает на данный адрес стека

Стек идет от большего к меньшему адресу, то есть например добавив в него данные адрес rsp уменьшается, а забирая увеличивается

В стеке можно хранить что угодно, он является неким временным хранилищем, удобно использовать место переменных и регистров

***последний зашел, первый вышел*** - принцип стека

- **push** - положить что-то в конец стека
- **pop** - получить что-то из конца стека

В стек можно класть данные кратные 16 битам, то есть 16 и 64, а 32 просто расширяются до 64

```asm
mov eax, 16
mov ebx, 321
push eax
push ebx
;.... ; что-то происходит
pop ebx ; ebx == 321
pop eax ; eax == 16
```

Так же для обращению к стеку можно использовать регистр rsp / esp

```asm
sup rsp, 8 ; зарезервировали 8 байт
mov dword[rsp], 321
mov dword[rsp + 4], 123 ; заполнили данными
mov eax, dword[rsp]
mov eax, dword[rsp + 4] ; получили данные
add rsp, 8
```

Можно комбинировать push / pop и rsp / esp

Так же лучше в конце привести rsp / esp в исходное состояние

Так же в стек можно записать регистр флагов используя **pushfq** и **popfq**

```asm
pushfq ; сохраняем
mov al, 123 
add al, 123
popfq ; востонавливем
```

---
## **movs / stos / rep** - копирование массива

- **movs** - копирует из esi в edi определенное кол-во байт 
- **stos** - копирует данные из регистра eax в участок памяти по регистру edi
- **rep** - повторяет определенную команду столько раз, сколько в регистре ecx

####

- **movsb:** извлекает байт по адресу RSI, сохраняет его по адресу RDI, а затем увеличивает или уменьшает регистры RSI и RDI на 1.
- **movsw:** выбирает слово по адресу RSI, сохраняет его по адресу RDI, а затем увеличивает или уменьшает RSI и RDI на 2.
- **movsd:** извлекает двойное слово по адресу RSI, сохраняет его по адресу RDI, а затем увеличивает или уменьшает адрес в регистрах RSI и RDI на 4.
- **movsq:** извлекает четверное слово по адресу RSI, сохраняет его по адресу RDI, а затем увеличивает или уменьшает адрес в регистрах RSI и RDI на 8.

####

- **stosb:** сохраняет 8-битное значение из регистра AL в строку
- **stosw:** сохраняет 16-битное значение из регистра AX в строку
- **stosd:** сохраняет 32-битное значение из регистра EAX в строку
- **stosq:** сохраняет 64-битное значение из регистра RAX в строку

Копирование массива в другой массив:

```asm
.data
    f db '%d',10,0
    name dd 1234,123412,123412,132
    name2 rd 4

.code
    mov esi, name ; передаем указатель на исходный массив
    mov edi, name2 ; передаем указатель на массив в который будет копироваться
    mov ecx, 4 ; кол-во элементов

    rep movsd ; копируем

    push [name2 + 4] ; [name2 + 4] == 123412
    push f
    call [printf]
```

Тут мы копируем уже н 4 раза по 4, а 2 рада по 8, ведь компу нет разницы, это ведь просто массив, а выполняться будет быстрее:

```asm
.data
    f db '%d',10,0
    name dd 1234,123412,123412,132
    name2 rd 4

.code
    mov esi, name ; передаем указатель на исходный массив
    mov edi, name2 ; передаем указатель на массив в который будет копироваться
    mov ecx, 2 ; кол-во элементов

    rep movsq ; копируем

    push [name2 + 4] ; [name2 + 4] == 123412
    push f
    call [printf]
```

Копирование элемента по всему массиву:

```asm
.data
    f db '%d',10,0
    name dd 1234,123412,123412,132

.code
    mov eax, 2222 ; то будет копироваться
    mov edi, name ; передаем указатель на массив в который будет копироваться
    mov ecx, 4 ; кол-во элементов

    rep stosd ; копируем

    push [name + 4] ; [name + 4] == 2222
    push f
    call [printf]
```

Можно сменить направление копирования, если поставить флаг направления используя **std** или снять флаг и все будет как обычно **cld**

```asm
.data
    f db '%d',10,0
    name dd 1234,123412,123412,132
    size db $-name
    name2 rd 4
    size2 db $-name2

.code
    lea esi, [name + size] ; передаем указатель на конец исходного массива
    lea edi, [name2 + size2] ; передаем указатель на конец массива в который будет копироваться
    mov ecx, 4 ; кол-во элементов
    
    std
    rep movsd ; копируем

    push [name2 + 4] ; [name2 + 4] == 123412
    push f
    call [printf]
```

---
## **cmps / repe / repne** - сравнение массивов

Для сравнения строк используется **cmps**, и так же регистры **esi** и **edi** для сравнения, и **ecx** для указания кол-ва


- **cmpsb:** сравнивает строку байтов
- **cmpsw:** сравнивает строку из слов
- **cmpsd:** сравнивает строку из двойных слов
- **cmpsq:** сравнивает строку из четверных слов

####

- Префикс **repe** указывает повторять операцию до тех пор, пока сравнение равно, или до количества раз, указанного RCX (в основном применяется для сравнений символьных строк).
- Префикс **repne** повторяет операцию, пока сравнение не равно, или до количества раз, указанного RCX

Так же можно инвертировать используя флаг направления

```asm
.data
    f db '%d',10,0
    name dd 1234,123412,123412,132
    size db ($-name)/4
    name2 dd 1234,123412,123412,132
    size2 db ($-name2)/4

.code
    mov eax, 2 ; задаем значение неудачи

    movsx ecx, [size]
    movsx ebx, [size2] 
    cmp ecx, ebx ; сравниваем размер
    jnz exit

    mov esi, name
    mov edi, name2

    repe cmpsd ; сравниваем массивы
    jnz exit

    mov eax, 1 ; если равны и дошли до сюда, то ставим значение удачи
exit:
    push eax
    push f
    call [printf]
```

---
## scas - поиск в массиве

Для поиска каких-то данных в других используется **scas** и регистры **edi**, **rax/eax/ax/al**

- **scasb:** поиск в строке байтов
- **scasw:** поиск в строке слов
- **scasd:** поиск в строке двойных слов
- **scasq:** поиск в строке четверных слов

В регистр **edi** передается указатель на массив, а **rax/eax/ax/al** данные которые в нем ищутся

При использовании **repe** ищется первый не совпадающий элемент

При использовании **repne** ищется первый совпавший элемент

По оканчанию поиска ставится флаг нуля и **edi** указывает на следующий элемент после найденного

Поиск также можно инвертировать используя флаг направления

```asm
section '.data' data readable writeable
    f db '%c',10,0
    name db 'oooox'

section '.code' code readable writeable executable

start:
    mov edi, name
    mov al, 'o'
    mov ecx, 5

    repe scasb ; ищет первый символ != 'o'
    jz noy

    movsx eax, byte[edi - 1]
    push eax
    push f
    call [printf]
noy:
    invoke ExitProcess, 69
```

```asm
section '.data' data readable writeable
    f db '%c',10,0
    name db 'lox'

section '.code' code readable writeable executable

start:
    mov edi, name
    mov al, 'o'
    mov ecx, 3

    repne scasb ; ищет первый символ == 'o'
    jnz noy

    movsx eax, byte[edi - 1]
    push eax
    push f
    call [printf]
noy:
    invoke ExitProcess, 69
```